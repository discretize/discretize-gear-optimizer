use crate::{
    data::{
        affix::Affix,
        attribute::Attribute,
        character::{AttributesArray, Character},
        settings::{Condition, Settings},
    },
    result::Result,
    utils::{clamp, round_even},
};
use std::cell::RefCell;
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::DedicatedWorkerGlobalScope;

/// Uses depth-first search to calculate all possible combinations of affixes for the given subtree.
///
/// # Arguments
/// * `affix_array` - An array of vectors of affixes. Each entry in the array corresponds to the affixes selectable for a specific slot. The array is of length 14, because there are 14 slots. However, if the last slot is not used due to two-handed weapons, the last entry in the array is Affix::None
/// * `subtree` - The current subtree of the affix tree. This is a vector of affixes. The length of the vector is the current layer of the tree. The first entry in the vector is the root of the tree.
/// * `leaf_callback` - A function that is called when a leaf of the tree is reached. The function is passed the current subtree.
pub fn descend_subtree_dfs<F>(
    affix_array: &[Vec<Affix>],
    subtree: &[Affix],
    max_depth: usize,
    leaf_callback: &mut F,
) where
    F: FnMut(&[Affix]),
{
    let current_layer = subtree.len();

    if current_layer == max_depth {
        // if we reached leafs of the tree, call the function
        leaf_callback(subtree);
    } else {
        let permutation_options = &affix_array[current_layer];

        let mut new_subtree: Vec<Affix> = Vec::with_capacity(subtree.len() + 1);
        new_subtree.clear();
        new_subtree.extend_from_slice(subtree);

        for &option in permutation_options {
            new_subtree.push(option);
            descend_subtree_dfs(affix_array, &new_subtree, max_depth, leaf_callback);
            new_subtree.pop();
        }
    }
}

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}
/// Starts the optimization process. Calculates all possible combinations for the given chunk (subtree) of the affix tree.
/// This process is independent of the other chunks.
///
/// # Arguments
/// * `chunks` - A vector of vectors of affixes. Each chunk represents a subtree of the affix tree. The chunks are generated by the JS code and distributed to multiple web workers.
/// * `combinations` - A vector of extras combinations. To calculate the best runes and sigils we must calculate the resulting stats for each combination of extras. Also contains important optimizer settings.
pub fn start(chunks: &Vec<Vec<Affix>>, combinations: &Vec<Settings>) -> Result {
    let rankby = combinations[0].rankby;
    // calculate the number of results we need to store;
    let result_num = combinations[0].maxResults; // as f32 / total_threads as f32;

    // we store our results in a Result object
    let mut result: Result = Result::new(result_num as usize);

    let counter = RefCell::new(0);
    let mut character = Character::new(rankby);

    let max_depth = &combinations[0].slots;

    // this callback is called for every affix combination (leaf). this is where we calculate the resulting stats
    // crucuial to optimize every call in this function as it will be called millions of times
    let mut callback = |subtree: &[Affix]| {
        // Leaf callback implementation

        // iterate over all combinations
        for i in 0..combinations.len() {
            let setting = &combinations[i];
            character.clear();
            character.combination_id = i as u32;

            // calculate stats for this combination
            let valid = test_character(&mut character, setting, subtree);

            if valid {
                // insert into result_characters if better than worst character
                result.insert(&character);
            }
            *counter.borrow_mut() += 1;

            // post message to js
            if *counter.borrow() % 100000 == 0 {
                // neither of these work - comment them in/out

                // method 1
                let worker_global_scope: DedicatedWorkerGlobalScope = js_sys::global()
                    .unchecked_into::<web_sys::WorkerGlobalScope>()
                    .unchecked_into();
                worker_global_scope
                    .post_message(&JsValue::from_str("yadda"))
                    .unwrap();

                // method 2
                log(&format!("Hello, !"));
            }
        }
    };

    for chunk in chunks {
        // start dfs into tree

        // TODO
        // will need to add another for loop here to iterate over all combinations
        // there are two options for this:
        // 1. add another for loop here and iterate over all combinations; start DFS in total #combinations * #chunks times
        // 2. loop over combination in callback and start DFS only #chunks times
        // ```
        // for _ in 0..combinations.len() {
        //     descend_subtree_dfs(affix_array, &chunk, *max_depth as usize, &mut callback);
        // }
        // ```

        descend_subtree_dfs(
            &combinations[0].affixesArray,
            &chunk,
            *max_depth as usize,
            &mut callback,
        );
    }

    // console::log_1(&JsValue::from_str(&format!(
    //     "Total combinations: {}",
    //     counter.borrow()
    // )));

    return result;
}

fn test_character(character: &mut Character, settings: &Settings, subtree: &[Affix]) -> bool {
    // add base attributes from settings to character
    settings.baseAttributes.iter().for_each(|(key, value)| {
        character.base_attributes.set_a(*key, *value);
    });

    for (index, affix) in subtree.iter().enumerate() {
        // find out stats for each affix and add them to the character
        let index_in_affix_array = settings.affixesArray[index]
            .iter()
            .position(|&r| r.to_number() == affix.to_number())
            .unwrap();
        let attributes_to_add = &settings.affixStatsArray[index][index_in_affix_array];

        attributes_to_add.iter().for_each(|(key, value)| {
            character.base_attributes.add_a(*key, *value);
        });

        character.gear[index] = *affix;
    }

    // calculate stats for the character
    return update_attributes(character, settings, false);
}

fn update_attributes(character: &mut Character, settings: &Settings, no_rounding: bool) -> bool {
    calc_stats(character, settings, no_rounding);
    //print_attr(&character.attributes);

    if character.is_invalid(settings) {
        return false;
    }

    let power_damage_score = calc_power(character, &settings);
    let condi_damage_score = calc_condi(character, &settings, &settings.relevantConditions);

    character.attributes.set_a(
        Attribute::Damage,
        power_damage_score + condi_damage_score + character.attributes.get_a(Attribute::FlatDPS),
    );

    // todo calcSurvivability
    // todo calcHealing

    return true;
}

fn calc_stats(character: &mut Character, settings: &Settings, no_rounding: bool) {
    // move base attributes to attributes as default
    // not sure which method is faster, but I think the for loop is faster:
    // 1. for loop
    // 2. clone
    for i in 0..character.base_attributes.len() {
        character.attributes[i] = character.base_attributes[i]
    }
    //character.attributes = character.base_attributes.clone();

    // get references to play with
    let attributes = &mut character.attributes;
    let base_attributes = &character.base_attributes;

    // closure for rounding values depending on no_rounding
    let round = |val: f32| {
        if no_rounding {
            val
        } else {
            round_even(val)
        }
    };

    // handle convert modifiers
    for (attribute, conversion) in &settings.modifiers.convert {
        let maybe_round = |val: f32| {
            if attribute.is_point_key() {
                round(val)
            } else {
                val
            }
        };

        for (source, percent) in conversion {
            attributes.add_a(
                *attribute,
                maybe_round(base_attributes.get_a(*source) * percent),
            );
        }
    }

    // handle buff modifiers, these are simply added to the existing attributes
    for (attribute, bonus) in &settings.modifiers.buff {
        attributes.add_a(*attribute, *bonus);
    }

    // recalculate attributes
    attributes.add_a(
        Attribute::CriticalChance,
        (attributes.get_a(Attribute::Precision) - 1000.0) / 21.0 / 100.0,
    );
    attributes.add_a(
        Attribute::CriticalDamage,
        attributes.get_a(Attribute::Ferocity) / 15.0 / 100.0,
    );
    attributes.add_a(
        Attribute::BoonDuration,
        attributes.get_a(Attribute::Concentration) / 15.0 / 100.0,
    );
    attributes.set_a(
        Attribute::Health,
        round(
            (attributes.get_a(Attribute::Health) + attributes.get_a(Attribute::Vitality) * 10.0)
                * (1.0 + attributes.get_a(Attribute::MaxHealth)),
        ),
    );

    // clones/phantasms/shroud
    //TODO

    // handle convertAfterBuffs modifiers
    for (attribute, conversion) in &settings.modifiers.convertAfterBuffs {
        let maybe_round = |val: f32| {
            if attribute.is_point_key() {
                round(val)
            } else {
                val
            }
        };

        for (source, percent) in conversion {
            match *source {
                Attribute::CriticalChance => {
                    attributes.add_a(
                        *attribute,
                        maybe_round(
                            clamp(attributes.get_a(Attribute::CriticalChance), 0.0, 1.0) * percent,
                        ),
                    );
                }
                Attribute::CloneCriticalChance => {
                    // replace macro with set
                    attributes.add_a(
                        *attribute,
                        maybe_round(
                            clamp(attributes.get_a(Attribute::CloneCriticalChance), 0.0, 1.0)
                                * percent,
                        ),
                    );
                }
                Attribute::PhantasmCriticalChance => {
                    attributes.add_a(
                        *attribute,
                        maybe_round(
                            clamp(
                                attributes.get_a(Attribute::PhantasmCriticalChance),
                                0.0,
                                1.0,
                            ) * percent,
                        ),
                    );
                }

                _ => {
                    attributes.add_a(*attribute, maybe_round(attributes.get_a(*source) * percent));
                }
            }
        }
    }
}

pub fn calc_power(character: &mut Character, settings: &Settings) -> f32 {
    let attributes = &mut character.attributes;
    let mods = &settings.modifiers;

    let crit_dmg = attributes.get_a(Attribute::CriticalDamage)
        * mods.get_dmg_multiplier(Attribute::CriticalDamage);
    let crit_chance = clamp(attributes.get_a(Attribute::CriticalChance), 0.0, 1.0);

    attributes.set_a(
        Attribute::EffectivePower,
        attributes.get_a(Attribute::Power)
            * (1.0 + crit_chance * (crit_dmg - 1.0))
            * mods.get_dmg_multiplier(Attribute::StrikeDamage),
    );
    attributes.set_a(
        Attribute::NonCritEffectivePower,
        attributes.get_a(Attribute::Power) * mods.get_dmg_multiplier(Attribute::StrikeDamage),
    );

    // 2597: standard enemy armor value, also used for ingame damage tooltips
    let power_damage = (attributes.get_a(Attribute::PowerCoefficient) / 2597.0)
        * attributes.get_a(Attribute::EffectivePower)
        + (attributes.get_a(Attribute::NonCritPowerCoefficient) / 2597.0)
            * attributes.get_a(Attribute::NonCritEffectivePower);
    // this is nowhere read again?
    attributes.set_a(Attribute::PowerDPS, power_damage);

    if attributes.get_a(Attribute::Power2Coefficient) > 0.0 {
        // do stuff
        //TODO implement power2 calc
    } else {
        attributes.set_a(Attribute::Power2DPS, 0.0);
    }

    let siphon_damage = attributes.get_a(Attribute::SiphonBaseCoefficient)
        * mods.get_dmg_multiplier(Attribute::SiphonDamage);

    attributes.set_a(Attribute::SiphonDPS, siphon_damage);

    return power_damage + siphon_damage;
}

/// Calculates a damage tick for a given condition
///
/// # Arguments
/// - `condition` - the condition to calculate the damage for
/// - `cdmg` - the condition damage of the character
/// - `mult` - the damage multiplier
/// - `wvw` - whether the calculation is for wvw or not
/// - `special` - whether the calculation is for a special condition or not such as ConfusionActive or TormentMoving
fn condition_damage_tick(
    condition: &Condition,
    cdmg: f32,
    mult: f32,
    wvw: bool,
    special: bool,
) -> f32 {
    (condition.get_factor(wvw, special) * cdmg + condition.get_base_damage(wvw, special)) * mult
}

pub fn calc_condi(
    character: &mut Character,
    settings: &Settings,
    relevant_conditions: &Vec<Condition>,
) -> f32 {
    let attributes = &mut character.attributes;
    let mods = &settings.modifiers;

    attributes.add_a(
        Attribute::ConditionDuration,
        attributes.get_a(Attribute::Expertise) / 15.0 / 100.0,
    );

    let mut condi_damage_score = 0.0;
    // iterate over all (relevant) conditions
    for condition in relevant_conditions.iter() {
        let cdmg = attributes.get_a(Attribute::ConditionDamage);
        let mult = mods.get_dmg_multiplier(Attribute::ConditionDamage)
            * mods.get_dmg_multiplier(condition.get_damage_attribute());

        match condition {
            Condition::Confusion => {
                attributes.set_a(
                    Attribute::ConfusionDamage,
                    condition_damage_tick(condition, cdmg, mult, settings.is_wvw(), false)
                        + condition_damage_tick(condition, cdmg, mult, settings.is_wvw(), true)
                            * settings.attackRate,
                );
            }
            Condition::Torment => {
                attributes.set_a(
                    Attribute::TormentDamage,
                    condition_damage_tick(condition, cdmg, mult, settings.is_wvw(), false)
                        * (1.0 - settings.movementUptime)
                        + condition_damage_tick(condition, cdmg, mult, settings.is_wvw(), true)
                            * settings.movementUptime,
                );
            }
            _ => attributes.set_a(
                condition.get_damage_attribute(),
                condition_damage_tick(condition, cdmg, mult, settings.is_wvw(), false),
            ),
        }

        let coeff = attributes.get_a(condition.get_coefficient_attribute());

        let duration = 1.0
            + clamp(
                attributes.get_a(condition.get_duration_attribute())
                    + attributes.get_a(Attribute::ConditionDuration),
                0.0,
                1.0,
            );

        let stacks = coeff * duration;
        attributes.set_a(condition.get_stacks_attribute(), stacks);

        let dmgattr = attributes.get_a(condition.get_damage_attribute());
        let dps = stacks * if dmgattr > 0.0 { dmgattr } else { 1.0 };
        attributes.set_a(condition.get_dps_attribute(), dps);

        condi_damage_score += dps;
    }

    condi_damage_score
}
